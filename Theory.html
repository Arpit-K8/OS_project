<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theory of Page Replacement Algorithm</title>
    <link rel="stylesheet" href="theory.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>


    <!-- Nav bar -->
     <div class="nav">
        <div class="head">Theory</div>
        <div class="navlist">
            <ul >
                <li><a href="Index.html">Home</a></li>
                <li><a href="AboutUs.html">About Us</a></li>
            </ul>
        </div>
     </div>
     <!-- sections starts from here -->
     <!-- first section -->
     <section class="header">
        <div class="header1">
            <h1>üìö Page Replacement Algorithms - Theory and Explanation</h1>
        </div>

        <div>
            <p>Page replacement algorithms are used in operating systems to manage memory efficiently when the system runs out of physical memory (RAM). When a program needs to access a memory page that is not in RAM, a page fault occurs, and the system needs to bring the required page into memory. If the memory is full, a page replacement algorithm decides which page to remove to make space for the new one.</p>
        </div>
   
     </section>


     <!-- section for the dropdown menu -->
      <section class="header">
        <h1><strong>üìñ Types of Page Replacement Algorithms: </strong></h1>

      </section>


     <!-- second section -->
   

     <section class="header">
       <h1>üîé 1. First In First Out (FIFO)</h1>
       <ul class="secli">
            <li><strong>Concept: </strong>The oldest page in memory is replaced first.</li>
            <li><strong>Working: </strong>It uses a simple queue to keep track of the order of pages.</li>
            <li><strong>Example: </strong>
                <div class="example">
                <div><strong>Pages: </strong>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</div>
                <div><strong>Frame Size: </strong>3</div>
                </div>

                <ul class="secli">
                    <li>Step 1: Insert pages 1, 2, and 3 ‚Üí [1, 2, 3]</li>
                    <li>Step 2: Page 4 comes, remove Page 1 ‚Üí [4, 2, 3]</li>
                    <li>Step 3: Continue following the FIFO rule.</li>
                </ul>
            </li>
       </ul>

       <div><strong>Advantages: </strong></div>
       <div>
        Easy to implement using a queue.
       </div>

       <div><strong>Disadvantages:</strong> </div>
       <div>May cause <strong>Belady‚Äôs Anomaly </strong>(increased frame size leads to more page faults).</div>
     </section>

     <!-- second section ends here -->


     <!-- third section starts from here-->

     <section class="header">
        <h1>üîé 2. Least Recently Used (LRU)</h1>

        <ul class="secli">
            <li><strong>Concept: </strong>The page that has not been used for the longest time is removed.</li>
            <li><strong>Working: </strong> It tracks the usage of each page using a timestamp or stack.</li>
            <li><strong>Example: </strong>
                <div class="example">
                    <div><strong>Pages: </strong>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</div>
                    <div><strong>Frame Size: </strong>3</div>
                </div>

                <ul class="secli">
                    <li>Step 1: Insert pages 1, 2, and 3 ‚Üí [1, 2, 3]</li>
                    <li>Step 2: Page 4 comes, remove Page 1 (least recently used) ‚Üí [4, 2, 3]</li>
                   
                </ul>
            </li>
        </ul>

        <div><strong>Advantages: </strong></div>
       <div>
        Better than FIFO in most scenarios.
       </div>

       <div><strong>Disadvantages:</strong> </div>
       <div>May cause <strong>Belady‚Äôs Anomaly </strong>(increased frame size leads to more page faults).</div>


     </section>

     <!-- third section ends here -->



     <!-- fouth section starts from here -->

     <section class="header neon-gradient-box">
        <h1>üîé 3. Optimal Page Replacement (OPT)</h1>

        <ul class="secli">
            <li><strong>Concept: </strong>Replace the page that will not be used for the longest time in the future.</li>
            <li><strong>Working: </strong> This algorithm uses future knowledge, which is generally impractical but serves as a benchmark.</li>
            <li><strong>Example: </strong>
                <div class="example">
                    <div><strong>Pages: </strong>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</div>
                    <div><strong>Frame Size: </strong>3</div>
                </div>

                <ul class="secli">
                    <li>Step 1:  Insert pages 1, 2, and 3 ‚Üí [1, 2, 3]</li>
                    <li>Step 2: Page 4 comes. Since Page 3 will not be used soon, replace it ‚Üí [1, 2, 4]</li>
                </ul>
            </li>
        </ul>


        <div><strong>Advantages: </strong></div>
       <div>
        Better than FIFO in most scenarios.
       </div>

       <div><strong>Disadvantages:</strong> </div>
       <div>May cause <strong>Belady‚Äôs Anomaly </strong>(increased frame size leads to more page faults).</div>

     </section>

     <!-- fourth section ends here -->


     <!-- fifth section starts from here:  Performance metrices-->

     <section class="header innerParent">
       <h2>‚úÖ Performance Metrics for Page Replacement Algorithms</h2> 
        <p>Evaluating page replacement algorithms involves comparing the following metrics:</p>

        <div class="innerflex">

        <div class="faults inner one">
            <h3>üìå 1. Page Faults</h3>
            <ul class="secli">

                <li>Occurs when a requested page is not found in memory.</li>
                <li>Formula:
                    <div><strong>Page Fault Rate</strong> = Number of Page Faults / Total Number of Page Requests</div>
                </li>
                <li><strong>Goal: </strong>Minimize page faults.</li>
            </ul>
        </div>
        <div class="hit inner two">
            <h3>üìå 2. Page Hit Ratio</h3>
            <ul class="secli">
                <li>A <strong>page hit</strong> occurs when a requested page is found in memory.</li>
                <li>Formula:
                    <div><strong>Hit Ratio</strong> = Number of Page Hits/ Total Number of Page Requests</div>
                </li>
                <li><strong>Goal: </strong>Maximize the hit ratio.</li>
            </ul>
        </div>
        <div class="memory inner three">
            <h3>üìå 3. Memory Utilization</h3>
            <ul class="secli">
                <li>Represents how efficiently memory is used.</li>
                <li><strong>Goal: </strong>Achieve maximum memory utilization with fewer page faults.</li>
                
            </ul>
        </div>
        <div class="time inner four">
            <h3>üìå 4. Execution Time</h3>
            <ul class="secli">
                <li>Time taken to process all page requests, including page fault handling.</li>
                <li><strong>Goal: </strong>Reduce the execution time.</li>
            </ul>
        </div>


    </div>


     </section>

     <!-- fifth section ends here - performance metrices -->

     <!-- sixth section table starts from here -->
      <section class="header">
        <h1>‚öñÔ∏è Comparison Table of Algorithms</h1>
        <div class="table">
        <table border="2">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>FIFO</th>
                    <th>LRU</th>
                    <th>Optimal</th>
                </tr>
                
            </thead>
            <tbody>
                <tr>
                    <td>Page Faults</td>
                    <td>High</td>
                    <td>Moderate</td>
                    <td>Low</td>
                </tr>

                <tr>
                    <td>Hit Ratio</td>
                    <td>Low</td>
                    <td>Moderate</td>
                    <td>High</td>
                </tr>

                <tr>
                    <td>Implementation Complexity</td>
                    <td>Simple</td>
                    <td>Moderate</td>
                    <td>Complex(Impractical)</td>
                </tr>

                <tr>
                    <td>Real-World Usage</td>
                    <td>Rare</td>
                    <td>Common</td>
                    <td>BenchMarking Only</td>
                </tr>
            </tbody>
        </table>

        </div>
      </section>

      <!-- sixth table section ends here  - table section-->


      <!-- seventh section starts from here - endpoint -->
       <section class="header">
        <h1>üìò Final Thoughts</h1>
        <ul>
            <li><strong>FIFO</strong> is simple but inefficient due to <strong>Belady's Anomaly.</strong></li>
            <li><strong>LRU</strong> is practical and widely used in modern systems.</li>
            <li><strong>Optimal</strong> is ideal but impossible to implement without future knowledge.</li>
        </ul>
       </section>
    
</body>
</html>
